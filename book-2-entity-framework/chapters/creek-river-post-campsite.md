# Chapter to POST a campsite

In this chapter, we'll create an API endpoint to add a new campsite to our database using Entity Framework Core. This will allow clients to create new campsites by sending HTTP POST requests to our API.

## Understanding HTTP POST Requests

HTTP POST is one of the HTTP methods defined in the HTTP protocol. It is used to send data to the server to create or update a resource. In RESTful APIs, POST requests are typically used to create new resources.

When a client sends a POST request to our API, it includes a JSON payload in the request body that contains the data for the new resource. Our API will process this data, create a new resource, and return a response with information about the newly created resource.

## Creating the POST Endpoint

Let's create an endpoint to add a new campsite to our database:

1. Open the `Program.cs` file.

2. Add the following endpoint after the existing endpoints:

```csharp
app.MapPost("/api/campsites", (CreekRiverDbContext db, Campsite campsite) =>
{
    db.Campsites.Add(campsite);
    db.SaveChanges();
    return Results.Created($"/api/campsites/{campsite.Id}", campsite);
});
```

Let's break down this code:

- `app.MapPost("/api/campsites", ...)`: This maps HTTP POST requests to the `/api/campsites` URL to our handler function.

- `(CreekRiverDbContext db, Campsite campsite) => { ... }`: This is the handler function. The `CreekRiverDbContext` parameter is injected by ASP.NET Core's dependency injection system, and the `Campsite` parameter is bound to the JSON payload in the request body.

- `db.Campsites.Add(campsite)`: This adds the new campsite to the `Campsites` DbSet in our DbContext. At this point, the campsite is only tracked by the DbContext but not yet saved to the database.

- `db.SaveChanges()`: This saves the changes to the database. It executes an SQL INSERT statement to add the new campsite to the `Campsites` table.

- `return Results.Created($"/api/campsites/{campsite.Id}", campsite)`: This returns a 201 Created response with a Location header pointing to the URL of the newly created campsite and the campsite data in the response body.

## Understanding Entity Framework Core's Change Tracking

Entity Framework Core tracks changes to entities that are attached to the DbContext. When you call `Add`, `Update`, or `Remove` on a DbSet, EF Core starts tracking the entity and records the operation that should be performed when `SaveChanges` is called.

When you call `SaveChanges`, EF Core executes the appropriate SQL statements to apply the tracked changes to the database. For example, when you add a new campsite and call `SaveChanges`, EF Core executes an INSERT statement.

After the INSERT statement is executed, EF Core automatically updates the `Id` property of the campsite entity with the value generated by the database. This is why we can use `campsite.Id` in the URL for the Location header.

## Testing the Endpoint

Now that we've created our endpoint, let's test it:

1. Run the application with `dotnet run` or by pressing F5 in Visual Studio.

2. Use a tool like Yaak to send a POST request to `https://localhost:<port>/api/campsites` with a JSON payload like:

```json
{
  "nickname": "Blue Heron",
  "imageUrl": "https://example.com/blue-heron.jpg",
  "campsiteTypeId": 1
}
```

3. You should receive a 201 Created response with the newly created campsite in the response body, including the ID assigned by the database.

## Adding Validation

Our current endpoint accepts any campsite data without validation. Let's add some basic validation to ensure that the required fields are provided:

```csharp
app.MapPost("/api/campsites", (CreekRiverDbContext db, Campsite campsite) =>
{
    // Validate required fields
    if (string.IsNullOrEmpty(campsite.Nickname))
    {
        return Results.BadRequest("Nickname is required.");
    }

    if (campsite.CampsiteTypeId <= 0)
    {
        return Results.BadRequest("Valid CampsiteTypeId is required.");
    }

    // Check if the CampsiteTypeId exists
    var campsiteType = db.CampsiteTypes.Find(campsite.CampsiteTypeId);
    if (campsiteType == null)
    {
        return Results.BadRequest($"CampsiteType with ID {campsite.CampsiteTypeId} does not exist.");
    }

    db.Campsites.Add(campsite);
    db.SaveChanges();
    return Results.Created($"/api/campsites/{campsite.Id}", campsite);
});
```

This code adds validation to ensure that:
1. The `Nickname` field is not null or empty.
2. The `CampsiteTypeId` is a positive number.
3. The `CampsiteTypeId` references an existing campsite type.

## Handling Exceptions

Our current endpoint doesn't handle exceptions that might occur during the database operation. Let's add exception handling:

```csharp
app.MapPost("/api/campsites", (CreekRiverDbContext db, Campsite campsite) =>
{
    // Validation code...

    try
    {
        db.Campsites.Add(campsite);
        db.SaveChanges();
        return Results.Created($"/api/campsites/{campsite.Id}", campsite);
    }
    catch (DbUpdateException ex)
    {
        return Results.BadRequest($"Error saving campsite: {ex.Message}");
    }
});
```

This code catches `DbUpdateException`, which is thrown when there's an error saving changes to the database, such as a constraint violation.

## Using DTOs for Input and Output

In a real-world application, you might want to use DTOs (Data Transfer Objects) for input and output to decouple your API contract from your database schema. Here's how you might modify the endpoint to use DTOs:

```csharp
app.MapPost("/api/campsites", (CreekRiverDbContext db, CampsiteCreateDTO campsiteDTO) =>
{
    // Validate DTO...

    // Map DTO to entity
    var campsite = new Campsite
    {
        Nickname = campsiteDTO.Nickname,
        ImageUrl = campsiteDTO.ImageUrl,
        CampsiteTypeId = campsiteDTO.CampsiteTypeId
    };

    db.Campsites.Add(campsite);
    db.SaveChanges();

    // Map entity to DTO for response
    var responseDTO = new CampsiteDTO
    {
        Id = campsite.Id,
        Nickname = campsite.Nickname,
        ImageUrl = campsite.ImageUrl,
        CampsiteTypeId = campsite.CampsiteTypeId
    };

    return Results.Created($"/api/campsites/{campsite.Id}", responseDTO);
});
```

You would need to define a `CampsiteCreateDTO` class that represents the data needed to create a campsite:

```csharp
public class CampsiteCreateDTO
{
    public string Nickname { get; set; }
    public string ImageUrl { get; set; }
    public int CampsiteTypeId { get; set; }
}
```

## The Complete Endpoint

Here's the complete endpoint with validation, exception handling, and DTOs:

```csharp
app.MapPost("/api/campsites", (CreekRiverDbContext db, CampsiteCreateDTO campsiteDTO) =>
{
    // Validate required fields
    if (string.IsNullOrEmpty(campsiteDTO.Nickname))
    {
        return Results.BadRequest("Nickname is required.");
    }

    if (campsiteDTO.CampsiteTypeId <= 0)
    {
        return Results.BadRequest("Valid CampsiteTypeId is required.");
    }

    // Check if the CampsiteTypeId exists
    var campsiteType = db.CampsiteTypes.Find(campsiteDTO.CampsiteTypeId);
    if (campsiteType == null)
    {
        return Results.BadRequest($"CampsiteType with ID {campsiteDTO.CampsiteTypeId} does not exist.");
    }

    try
    {
        // Map DTO to entity
        var campsite = new Campsite
        {
            Nickname = campsiteDTO.Nickname,
            ImageUrl = campsiteDTO.ImageUrl,
            CampsiteTypeId = campsiteDTO.CampsiteTypeId
        };

        db.Campsites.Add(campsite);
        db.SaveChanges();

        // Map entity to DTO for response
        var responseDTO = new CampsiteDTO
        {
            Id = campsite.Id,
            Nickname = campsite.Nickname,
            ImageUrl = campsite.ImageUrl,
            CampsiteTypeId = campsite.CampsiteTypeId
        };

        return Results.Created($"/api/campsites/{campsite.Id}", responseDTO);
    }
    catch (DbUpdateException ex)
    {
        return Results.BadRequest($"Error saving campsite: {ex.Message}");
    }
});
```

## Conclusion

In this chapter, we've created an API endpoint to add a new campsite to our database using Entity Framework Core. We've learned how to:

1. Create a POST endpoint to add a new resource
2. Use Entity Framework Core to add a new entity to the database
3. Return a 201 Created response with the newly created resource
4. Add validation to ensure that the required fields are provided
5. Handle exceptions that might occur during the database operation
6. Use DTOs for input and output to decouple the API contract from the database schema

These concepts are fundamental to creating RESTful APIs with ASP.NET Core and Entity Framework Core.

In the next chapter, we'll create an endpoint to delete a campsite from the database.

Up Next: [Chapter to DELETE a campsite](./creek-river-delete-campsite.md)

## ðŸ” Additional Materials

- [ASP.NET Core Minimal APIs](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis)
- [Entity Framework Core - Saving Data](https://docs.microsoft.com/en-us/ef/core/saving/)
- [Entity Framework Core - Change Tracking](https://docs.microsoft.com/en-us/ef/core/change-tracking/)
- [HTTP POST Method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST)
- [RESTful API Design](https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design)